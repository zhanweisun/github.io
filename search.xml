<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>无需权限获取应用程序列表</title>
      <link href="/2019/12/29/get-app-list/"/>
      <url>/2019/12/29/get-app-list/</url>
      
        <content type="html"><![CDATA[<h3 id="无需权限获取应用程序列表"><a href="#无需权限获取应用程序列表" class="headerlink" title="无需权限获取应用程序列表"></a>无需权限获取应用程序列表</h3><p>最近在研究反编译的时候发现了系统的一种漏洞方式获取应用程序信息,这个可以无需任何权限,用户无任何感知的获取全部应用程序列表,这对于一些特别需要知道用户手机内是否安装了某些特定应用的的人来说真的是太好了.</p><p>经过我自己的实验,华为三星等手机没有任何问题.简单的跟大家分享一下我的研究成果.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">getPackageList</span><span class="token punctuation">(</span>Context ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"TAG"</span><span class="token punctuation">,</span> <span class="token string">"无需权限获取应用列表"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        PackageManager v9 <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getPackageManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> v2 <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">int</span> uid <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>uid <span class="token operator">&lt;=</span> <span class="token number">19999</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            v2 <span class="token operator">=</span> v9<span class="token punctuation">.</span><span class="token function">getPackagesForUid</span><span class="token punctuation">(</span>uid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>v2 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> v2<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>String item <span class="token operator">:</span> v2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        <span class="token keyword">final</span> PackageInfo v6 <span class="token operator">=</span> v9<span class="token punctuation">.</span><span class="token function">getPackageInfo</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>v6 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        CharSequence v7 <span class="token operator">=</span> v9<span class="token punctuation">.</span><span class="token function">getApplicationLabel</span><span class="token punctuation">(</span>v9<span class="token punctuation">.</span><span class="token function">getApplicationInfo</span><span class="token punctuation">(</span>v6<span class="token punctuation">.</span>packageName<span class="token punctuation">,</span> PackageManager<span class="token punctuation">.</span>GET_META_DATA<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"TAG"</span><span class="token punctuation">,</span> <span class="token string">"应用名称 = "</span> <span class="token operator">+</span> v7<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" ("</span> <span class="token operator">+</span> v6<span class="token punctuation">.</span>packageName <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">PackageManager<span class="token punctuation">.</span>NameNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            uid<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 应用列表 </tag>
            
            <tag> android </tag>
            
            <tag> 权限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DEX文件结构与解析</title>
      <link href="/2019/12/28/dex-wen-jian-jie-gou-yu-jie-xi/"/>
      <url>/2019/12/28/dex-wen-jian-jie-gou-yu-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="DEX文件结构与解析"><a href="#DEX文件结构与解析" class="headerlink" title="DEX文件结构与解析"></a>DEX文件结构与解析</h1><p>Dex是Dalvik虚拟机的执行文件，对于每一个开发者来说，他的结构对于开发这至关重要，也是我们优化的一个方面，虽然很多工作是Android Stuido和其对应的工具进行的，但是我们需要知道他的基础结构和工作原理.由于近期的工作原因,特意研究了一下dex的完整结构,并且用kotlin写了完整的结构解析代码,除了dex具体的代码解析以外的其他结构解析都已经完成.特此总结一下学到的东西,希望与大家一起进步.</p><h3 id="前期准备工作"><a href="#前期准备工作" class="headerlink" title="前期准备工作"></a>前期准备工作</h3><p>1.我们在探索Dex文件结构时候需要使用一些工具，我个人推荐使用010Editor，加上Dex模板，这样更好的方便我们分析Dex的结构</p><p>2.分析的Dex文件是我自己用Timber（一个开元音乐播放器）代码编译的。如果需要可以自己找个合适的分析对象</p><h3 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h3><p>将dex从apk中解压出来，拖入010editor中，此时因为dex文件比较大，010Editor会提示是否继续进行分析</p><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/openDex.png?raw=true" alt=""></p><p>分析完成以后会在下面产生一个结构列表，我们分析就靠这个结构列表和对应的数据了。</p><p><strong><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/dexStruct.png?raw=true" alt="dexStruct"></strong></p><h4 id="Dex头部"><a href="#Dex头部" class="headerlink" title="Dex头部"></a>Dex头部</h4><p>首先我们用鼠标选中结构的第一行，可以看到上面文本去默认会被高亮，这第一段里面的就是Dex文件的头部</p><h5 id="MagicNumber"><a href="#MagicNumber" class="headerlink" title="MagicNumber"></a>MagicNumber</h5><p>Dex文件头的前8个byte是用来识别dex文件的MagicNumber，内容是Dex.035,并以00结尾，十六进制值为 <strong>64 65 78 0A 30 33 35 00</strong></p><h5 id="CheckSum"><a href="#CheckSum" class="headerlink" title="CheckSum"></a>CheckSum</h5><p>Dex文件的adler32校验和，长度4个字节，校验文件除去 maigc、checksum 外余下的所有文件区域</p><h5 id="SHA1-Signature"><a href="#SHA1-Signature" class="headerlink" title="SHA1 Signature"></a>SHA1 Signature</h5><p>接下来的20个字节是ＳＨＡ１的签名</p><h5 id="File-Size-文件长度"><a href="#File-Size-文件长度" class="headerlink" title="File Size 文件长度"></a>File Size 文件长度</h5><p>文件长度４个字节，所以单个Ｄｅｘ文件大小不可能超过４ＧＢ，但是因为可以拆分分多个Ｄｅｘ，所以使用４字节也是足够了</p><h5 id="Header-Size"><a href="#Header-Size" class="headerlink" title="Header Size"></a>Header Size</h5><p>长度４字节，标记整个头部的长度，这里的值是0x00 00 00 70,十进制是112，如果我们选中010Editor下面的结构框的第一个名字叫　struct header_item dex_header 的item ,我们就能发现，上面选中的结构大小刚好是0Ｈ到6FＨ,共计７０Ｈ个数据,这个值一般是固定的</p><h5 id="EndianTag"><a href="#EndianTag" class="headerlink" title="EndianTag"></a>EndianTag</h5><p>长度４个字节，用来标记大小端，默认值是0x12 34 56 78,指定ｃｐｕ的运行环境是大端还是小端，默认的ｉｎｔｅｌ使用的是小端，所以在010Editor上面看到的是78 56 34 12，这个请注意！！！</p><h5 id="LinkSize-amp-LinkOff-字段"><a href="#LinkSize-amp-LinkOff-字段" class="headerlink" title="LinkSize &amp; LinkOff 字段"></a>LinkSize &amp; LinkOff 字段</h5><p>这两个字段指定连接段的大小和对应的文件偏移地址，通常情况都为0，linksize为0表示静态链接</p><h5 id="mapOff"><a href="#mapOff" class="headerlink" title="mapOff"></a>mapOff</h5><p>指定了DexMapList的结构在Dex文件中的位置偏移，这个DexMapList结构是其他结构的一个数据大纲，里面记录了这些结构的一些信息。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> DexMapList <span class="token punctuation">{</span>    u4 size<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">/* DexMapItem的个数 */</span>    DexMapItem list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* DexMapItem的结构 */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> DexMapItem <span class="token punctuation">{</span>       u2 type<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* kDexType开头的类型 */</span>    u2 unused<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 未使用，用于字节对齐 */</span>    u4 size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* type指定类型的个数，它们在dex文件中连续存放 */</span>    u4 offset<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 指定类型数据的文件偏移 */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* type字段为一个枚举常量，通过类型名称很容易判断它的具体类型。 */</span><span class="token comment" spellcheck="true">/* map item type codes */</span><span class="token keyword">enum</span> <span class="token punctuation">{</span>    kDexTypeHeaderItem               <span class="token operator">=</span> <span class="token number">0x0000</span><span class="token punctuation">,</span>    kDexTypeStringIdItem             <span class="token operator">=</span> <span class="token number">0x0001</span><span class="token punctuation">,</span>    kDexTypeTypeIdItem               <span class="token operator">=</span> <span class="token number">0x0002</span><span class="token punctuation">,</span>    kDexTypeProtoIdItem              <span class="token operator">=</span> <span class="token number">0x0003</span><span class="token punctuation">,</span>    kDexTypeFieldIdItem              <span class="token operator">=</span> <span class="token number">0x0004</span><span class="token punctuation">,</span>    kDexTypeMethodIdItem             <span class="token operator">=</span> <span class="token number">0x0005</span><span class="token punctuation">,</span>    kDexTypeClassDefItem             <span class="token operator">=</span> <span class="token number">0x0006</span><span class="token punctuation">,</span>    kDexTypeMapList                  <span class="token operator">=</span> <span class="token number">0x1000</span><span class="token punctuation">,</span>    kDexTypeTypeList                 <span class="token operator">=</span> <span class="token number">0x1001</span><span class="token punctuation">,</span>    kDexTypeAnnotationSetRefList     <span class="token operator">=</span> <span class="token number">0x1002</span><span class="token punctuation">,</span>    kDexTypeAnnotationSetItem        <span class="token operator">=</span> <span class="token number">0x1003</span><span class="token punctuation">,</span>    kDexTypeClassDataItem            <span class="token operator">=</span> <span class="token number">0x2000</span><span class="token punctuation">,</span>    kDexTypeCodeItem                 <span class="token operator">=</span> <span class="token number">0x2001</span><span class="token punctuation">,</span>    kDexTypeStringDataItem           <span class="token operator">=</span> <span class="token number">0x2002</span><span class="token punctuation">,</span>    kDexTypeDebugInfoItem            <span class="token operator">=</span> <span class="token number">0x2003</span><span class="token punctuation">,</span>    kDexTypeAnnotationItem           <span class="token operator">=</span> <span class="token number">0x2004</span><span class="token punctuation">,</span>    kDexTypeEncodedArrayItem         <span class="token operator">=</span> <span class="token number">0x2005</span><span class="token punctuation">,</span>    kDexTypeAnnotationsDirectoryItem <span class="token operator">=</span> <span class="token number">0x2006</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/DexMapListStruct.jpeg?raw=true" alt="DexMapListStruct"></p><p>这个dex_map_list 结构保存在DEX文件的最末尾处，并且第一个字节就是保存的结构数量，也就是map_item的数量</p><p>map_item结构如下图所示,单一结构长度位12个字节，其中前两个字节是描述对应的段类型，紧跟着的2个字节是对齐字节，无意义。接下来的4个字节是对应的段大小，最后的4个字节是对应的段偏移，以上就是关于mapoff对应的内容的解释</p><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/map_item.jpeg?raw=true" alt=""></p><h5 id="stringIdsSize-amp-amp-stringIdsOff字段"><a href="#stringIdsSize-amp-amp-stringIdsOff字段" class="headerlink" title="stringIdsSize &amp;&amp; stringIdsOff字段"></a>stringIdsSize &amp;&amp; stringIdsOff字段</h5><p>这两个字段是用来标记所有字符串的，stringIdsSize标记字符串的数量，stringIdsOff标记字符串偏移的首地址，知道这两个数据以后，我们就可以进行字符串的解析了.</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> DexStringId <span class="token punctuation">{</span>    u4 stringDataOff<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 字符串数据偏移 */</span><span class="token punctuation">}</span></code></pre><p>我们先看一下stringIdsOff 这个值，截图如下</p><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/string_ids_off.jpeg?raw=true" alt="string_ids_off"></p><p>我们可以看到这个数值位 70 00 00 00,这个是不是很熟悉？我们去看一下，dex的header值是多少？ 是70H，因为我们这个数值存放的问题，实际这个偏移值就是70H。</p><p>也就是说，我们的Dex头部的后面紧跟着就是字符串的相关数据了。我们接着说字符串数据的解析</p><p>我们把结构选择到010Editor的第二个结构体，也就是struct string_id_list dex_string_ids这里，选中这个结构体我们可以看到这个结构的全部内容。如下</p><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/string_id_list.jpeg?raw=true" alt="string_id_list"></p><p>这里的展开的每一个item就是一个字符串的索引，这里强调一下是索引。不是真正的字符串。这个值对应的是真正的字符串的偏移地址，我们后面需要用到的字符串，会通过这个索引进行查表找到对应的字符串。</p><h5 id="typeIdsSize-amp-typeIdsOff"><a href="#typeIdsSize-amp-typeIdsOff" class="headerlink" title="typeIdsSize &amp; typeIdsOff"></a>typeIdsSize &amp; typeIdsOff</h5><p>类型区的大小和对应的类型名字的偏移索引。</p><p>这个索引的起始地址就是typeIdsOff对应的值，这个值在我的dex文件上面是0x00 02 DD 9C,然后这个起始地址开始有6393个数据，我们现在跳转到对应的地址看一下。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> DexTypeId <span class="token punctuation">{</span>    u4 descriptorIdx<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 指向 DexStringId列表的索引 */</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/type_ids_offset.jpeg?raw=true" alt="type_ids_offset"></p><p>想要精准的跳到对应的地址，我们可以直接选择结构列表里面的struct type_id_list dex_type_ids,010Editor会自动帮我们定位到对应的位置,这个时候我们再来看一下这个结构的全部数据，已经被选中了.如果我们展开这个结构，下面是每一个item的索引和item的内部结构，我们可以数一下索引的值，我这里的是从0-6392,一共是6393个结构。所以这个刚好跟我们头部的数据是对应的。</p><p>接下来我们看一些type_id_item的值，大家可以在010Editor里面进行查看。里面能够看到很多的类型,例如byte，float，还有这个dex中的类对应的类型</p><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/type_id.jpeg?raw=true" alt="type_id"></p><h5 id="protoIdsSize-amp-protoIdsOff"><a href="#protoIdsSize-amp-protoIdsOff" class="headerlink" title="protoIdsSize &amp; protoIdsOff"></a>protoIdsSize &amp; protoIdsOff</h5><p>protoIdsOff指向了函数原型的偏移地址，主要的标记内容  方法声明=返回类型 + 参数列表，protoIds标记对应的数量.从对应的value里面，我们就能看到函数返回值，参数类型等函数原型的标记</p><pre class=" language-c"><code class="language-c">zstruct DexProtoId <span class="token punctuation">{</span>    u4 shortyIdx<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 指向DexStringId列表的索引 */</span>    u4 returnTypeIdx<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 指向DexTypeId列表的索引 */</span>    u4 parametersOff<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 指向DexTypeList的偏移 */</span><span class="token punctuation">}</span><span class="token keyword">struct</span> DexTypeList <span class="token punctuation">{</span>    u4 size<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">/* 接下来DexTypeItem的个数 */</span>    DexTypeItem list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* DexTypeItem结构 */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> DexTypeItem <span class="token punctuation">{</span>    u2 typeIdx<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 指向DexTypeId列表的索引 */</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/proto_ids.jpeg?raw=true" alt="proto_ids"></p><h5 id="field-ids-size-amp-field-ids-off"><a href="#field-ids-size-amp-field-ids-off" class="headerlink" title="field_ids_size &amp; field_ids_off"></a>field_ids_size &amp; field_ids_off</h5><p>field_ids_off偏移地址指向的结构数据全部是索引值，指明了字段所在的类、字段的类型以及字段名</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> DexFieldId <span class="token punctuation">{</span>    u2 classIdx<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 类的类型，指向DexTypeId列表的索引 */</span>    u2 typeIdx<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 字段类型，指向DexTypeId列表的索引 */</span>    u4 nameIdx<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 字段名，指向DexStringId列表的索引 */</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>具体请看下图,class_idx 这个field所属的类的索引值，type_idx是这个field对应的类型索引值,name_idx是这个字段的名称对应的索引值</p><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/field_id.jpeg?raw=true" alt="field_id"></p><h6 id="method-ids-size-amp-method-ids-off"><a href="#method-ids-size-amp-method-ids-off" class="headerlink" title="method_ids_size &amp; method_ids_off"></a>method_ids_size &amp; method_ids_off</h6><p>method_ids_off 指定了函数方法的偏移位置，具体的字段如下代码所示</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> DexMethodId <span class="token punctuation">{</span>    u2 classIdx<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 类的类型，指向DexTypeId列表的索引 */</span>    u2 protoIdx<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 声明类型，指向DexProtoId列表的索引 */</span>    u4 nameIdx<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 方法名，指向DexStringId列表的索引 */</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>classIdx 指向这个方法所在的类对象的索引，通过索引可以获取到类对象的名称</p><p>protoIdx指向的是这个方法声明的原型字符串的索引</p><p>nameIdx获取这个方法名称的字符串索引</p><p> 有了这三个索引对应的字符串，我们就可以获取到正确的类，方法名，参数和返回值，还是使用我们的010Editor，我们打开method_id_list dex_method_ids这个结构下面的item，我们就可以看到这些数据获取以后，我们能知道的一些东西，具体看下图</p><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/method_idx.jpeg?raw=true" alt="method_idx"></p><p>我们可以在结构体的最上面看到整个的方法原型，这个是由下面的三个字段对应的字符串值拼接成的，可以完整的看到方法的声明细节。</p><h5 id="class-defs-size-amp-class-defs-off"><a href="#class-defs-size-amp-class-defs-off" class="headerlink" title="class_defs_size &amp; class_defs_off"></a>class_defs_size &amp; class_defs_off</h5><p>class_defs_off指向的是类定义的偏移地址，这里的类定义结构比较复杂，里面嵌套了很多层，我们先来看一下010Editor的结构</p><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/class_struct_item.jpeg?raw=true" alt="class_struct_item"></p><p>在这个结构里面，我们能看到一些基本的信息，比如class_idx索引等等,访问的标志等等,</p><p>class_def_item的结构如下</p><pre class=" language-c"><code class="language-c">uint   <span class="token number">32</span><span class="token operator">-</span>bit <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> little<span class="token operator">-</span>endian<span class="token keyword">struct</span> class_def_item<span class="token punctuation">{</span>    uint class_idx<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//描述具体的 class 类型，值是 type_ids 的一个 index 。值必须是一个 class 类型，不能是数组类型或者基本类型。   </span>    uint access_flags<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//描述 class 的访问类型，诸如 public , final , static 等。在 dex-format.html 里 “access_flags Definitions” 有具体的描述 </span>    uint superclass_idx<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//描述 supperclass 的类型，值的形式跟 class_idx 一样 </span>    uint interface_off<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//值为偏移地址，指向 class 的 interfaces，被指向的数据结构为 type_list 。class 若没有 interfaces 值为 0</span>    uint source_file_idx<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//表示源代码文件的信息，值是 string_ids 的一个 index。若此项信息缺失，此项值赋值为 NO_INDEX=0xffff ffff</span>    uint annotations_off<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//值是一个偏移地址，指向的内容是该 class 的注释，位置在 data 区，格式为 annotations_direcotry_item。若没有此项内容，值为 0 </span>    uint class_data_off<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//值是一个偏移地址，指向的内容是该 class 的使用到的数据，位置在 data 区，格式为 class_data_item。若没有此项内容值为 0。该结构里有很多内容，详细描述该 class 的 field、method, method 里的执行代码等信息，后面会介绍 class_data_item</span>    uint static_value_off<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//值是一个偏移地址 ，指向 data 区里的一个列表 (list)，格式为 encoded_array_item。若没有此项内容值为 0</span><span class="token punctuation">}</span></code></pre><p>如果仔细对比你就会发现，010Editor会将annotations_off指向的数据放在他的后面，class_data_off,static_values_off也是一样的处理方式，其实这些数据都在dex结构的其他地方，但是010Editor为了让你查看方便，把他们都放在了一起，实际的class_def_item结构都是指向和偏移，真正的解析都在对应的地址位置而不在这个类定义的结构里面</p><h6 id="class-def-item-中的-annotations-off指向的内容"><a href="#class-def-item-中的-annotations-off指向的内容" class="headerlink" title="class_def_item 中的 annotations_off指向的内容"></a>class_def_item 中的 annotations_off指向的内容</h6><p>annotations指向的是annotation 相关的数据描述，这个描述的结构具体如下</p><pre class=" language-c"><code class="language-c">uint   <span class="token number">32</span><span class="token operator">-</span>bit <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> little<span class="token operator">-</span>endian<span class="token keyword">struct</span> annotation_directory_item<span class="token punctuation">{</span>    uint class_annotations_off<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//从文件开头到直接在该类上所做的注释的偏移量；如果该类没有任何直接注释，则该值为 0。该偏移量（如果为非零值）应该是到 data 区段中某个位置的偏移量。数据格式由下文的“annotation_set_item”指定。</span>    uint fields_size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//此项所注释的字段数量</span>    uint annotated_methods_size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//此项所注释的方法数量</span>    uint annotated_parameters_size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//此项所注释的方法参数列表的数量</span>    field_annotation field_annotations<span class="token punctuation">[</span>fields_size<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（可选）    所关联字段的注释列表。该列表中的元素必须按 field_idx 以升序进行排序。</span>    method_annotation method_annotations<span class="token punctuation">[</span>annotated_methods_size<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（可选）    所关联方法的注释列表。该列表中的元素必须按 method_idx 以升序进行排序。</span>    parameter_annotation parameter_annotations<span class="token punctuation">[</span>annotated_parameters_size<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（可选）所关联方法参数的注释列表。该列表中的元素必须按 method_idx 以升序进行排序。</span><span class="token punctuation">}</span><span class="token keyword">struct</span> field_annotation<span class="token punctuation">{</span>    uint field_idx<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//字段（带注释）标识的 field_ids 列表中的索引</span>    uint annotations_off<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//字段（带注释）标识的 field_ids 列表中的索引</span><span class="token punctuation">}</span><span class="token keyword">struct</span> method_annotation<span class="token punctuation">{</span>    uint method_idx<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//方法（带注释）标识的 method_ids 列表中的索引</span>    uint annotations_off<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//从文件开头到该方法注释列表的偏移量。偏移量应该是到 data 区段中某个位置的偏移量。数据格式由下文的“annotation_set_item”指定。</span><span class="token punctuation">}</span><span class="token keyword">struct</span> parameter_annotation<span class="token punctuation">{</span>    uint method_idx<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//方法（其参数带注释）标识的 method_ids 列表中的索引</span>    uint annotations_off<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//从文件开头到该方法参数的注释列表的偏移量。偏移量应该是到 data 区段中某个位置的偏移量。数据格式由下文的“annotation_set_ref_list”指定。</span><span class="token punctuation">}</span><span class="token keyword">struct</span> annotation_set_ref_list<span class="token punctuation">{</span>    unit size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//列表的大小（以条目数表示）</span>    annotation_set_ref_item<span class="token punctuation">[</span>size<span class="token punctuation">]</span> list<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//列表的元素</span><span class="token punctuation">}</span><span class="token keyword">struct</span> annotation_set_ref_item<span class="token punctuation">{</span>    unit annotations_off<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//从文件开头到所引用注释集的偏移量；如果此元素没有任何注释，则该值为 0。该偏移量（如果为非零值）应该是到 data 区段中某个位置的偏移量。数据格式由下文的“annotation_set_item”指定。</span><span class="token punctuation">}</span><span class="token keyword">struct</span> annotation_set_item<span class="token punctuation">{</span>    unit size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//该集合的大小（以条目数表示）</span>    annotation_off_item<span class="token punctuation">[</span>size<span class="token punctuation">]</span> entries<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//该集合的元素。这些元素必须按 type_idx 以升序进行排序。</span><span class="token punctuation">}</span><span class="token keyword">struct</span> annotation_off_item<span class="token punctuation">{</span>    unit annotation_off<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//从文件开头到注释的偏移量。该偏移量应该是到 data 区段中某个位置的偏移量，且该位置的数据格式由下文的“annotation_item”指定。</span><span class="token punctuation">}</span><span class="token keyword">struct</span> annotation_item<span class="token punctuation">{</span>    ubyte visibility<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//此注释的预期可见性（见下文）</span>   encoded_annotation annotation<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//已编码的注释内容，采用上文的“encoded_value 编码”下的“encoded_annotation 格式”所述的格式。</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//可见值</span><span class="token comment" spellcheck="true">// VISIBILITY_BUILD            0x00    预计仅在构建时（例如，在编译其他代码期间）可见</span><span class="token comment" spellcheck="true">//VISIBILITY_RUNTIME    0x01    预计在运行时可见</span><span class="token comment" spellcheck="true">//VISIBILITY_SYSTEM          0x02      预计在运行时可见，但仅对基本系统（而不是常规用户代码）可见</span><span class="token keyword">struct</span> encoded_array_item<span class="token punctuation">{</span>    encoded_array value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用于表示编码数组值的字节，采用上文的“encoded_value 编码”下的“encoded_array 格式”指定的格式。</span><span class="token punctuation">}</span><span class="token keyword">struct</span> hiddenapi_class_data_item<span class="token punctuation">{</span>    unit size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//该区段的总大小</span>    unit<span class="token punctuation">[</span><span class="token punctuation">]</span> offsets<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//由 class_idx 编入索引的偏移量数组。索引 class_idx 中的零数组意味着此 class_idx 没有任何数据，或者所有隐藏 API 标记均为零。否则，数组条目为非零值，并且包含从该区段开头到此 class_idx 的隐藏 API 标记数组的偏移量。</span>    bleb128<span class="token punctuation">[</span><span class="token punctuation">]</span> flags<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//每个类的隐藏 API 标记的级联数组。可能的标记值如下表所述。标记按照字段的相同编码顺序进行编码，且方法在类数据中编码。</span><span class="token punctuation">}</span>限制标记类型：名称                      值            说明whitelist                <span class="token number">0</span>            此列表中的接口已在 Android 框架软件包索引中正式记录，它们是受支持的接口，您可以自由使用。greylist                <span class="token number">1</span>    包含可以使用的非 SDK 接口的列表（无论应用的目标 API 级别是什么）。blacklist                <span class="token number">2</span>    包含不能使用的非 SDK 接口的列表（无论应用的目标 API 级别是什么）。访问其中任何一个接口都会导致运行时错误。greylist‑max‑o    <span class="token number">3</span>    包含可用于 Android <span class="token number">8</span><span class="token punctuation">.</span>x 及下文的非 SDK 接口列表（除非这些接口受到限制）。greylist‑max‑p    <span class="token number">4</span>    包含可用于 Android <span class="token number">9</span><span class="token punctuation">.</span>x 的非 SDK 接口列表（除非这些接口受到限制）。greylist‑max‑q    <span class="token number">5</span>    包含可用于 Android <span class="token number">10</span><span class="token punctuation">.</span>x 的非 SDK 接口列表（除非这些接口受到限制）。</code></pre><p>如果需要可以参考google的官方文档(需要翻墙)</p><p><a href="https://source.android.com/devices/tech/dalvik/dex-format.html" target="_blank" rel="noopener">https://source.android.com/devices/tech/dalvik/dex-format.html</a></p><h6 id="class-def-item中的class-data-off"><a href="#class-def-item中的class-data-off" class="headerlink" title="class_def_item中的class_data_off"></a>class_def_item中的class_data_off</h6><p>指向 data 区里的 class_data_item 结构，class_data_item 里存放着本 class 使用到的各种数据，下面是 class_data_item 的结构 </p><pre class=" language-c"><code class="language-c">uleb128 <span class="token keyword">unsigned</span> little<span class="token operator">-</span>endian base <span class="token number">128</span> <span class="token keyword">struct</span> class_data_item<span class="token punctuation">{</span>    uleb128 static_fields_size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//静态成员变量的个数</span>    uleb128 instance_fields_size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//实例成员变量个数</span>    uleb128 direct_methods_size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//直接函数个数</span>    uleb128 virtual_methods_size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 虚函数个数</span>    encoded_field  static_fields<span class="token punctuation">[</span>static_fields_size<span class="token punctuation">]</span><span class="token punctuation">;</span>    encoded_field  instance_fields<span class="token punctuation">[</span>instance_fields_size<span class="token punctuation">]</span><span class="token punctuation">;</span>    encoded_method direct_methods<span class="token punctuation">[</span>direct_methods_size<span class="token punctuation">]</span><span class="token punctuation">;</span>    encoded_method virtual_methods<span class="token punctuation">[</span>virtual_methods_size<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> encoded_field<span class="token punctuation">{</span>    uleb128 filed_idx_diff<span class="token punctuation">;</span>     uleb128 access_flags<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token keyword">struct</span> encoded_method<span class="token punctuation">{</span>    uleb128 method_idx_diff<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//前缀 methd_idx 表示它的值是 method_ids 的一个 index ，后缀 _diff 表示它是于另 外一个 method_idx 的一个差值 ，就是相对于 encodeed_method [] 数组里上一个元素的 method_idx 的差值 。 其实 encoded_filed - > field_idx_diff 表示的也是相同的意思 ，只是编译出来的 Hello.dex 文件里没有使用到 class filed 所以没有仔细讲 ，详细的参考 https://source.android.com/devices/tech/dalvik/dex-format 官网文档。</span>    uleb128 access_flags<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//访问权限，比如 public、private、static、final 等</span>    uleb128 code_off<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一个指向 data 区的偏移地址，目标是本 method 的代码实现。被指向的结构是code_item，有近 10 项元素</span><span class="token punctuation">}</span><span class="token keyword">struct</span> code_item <span class="token punctuation">{</span>    ushort                         registers_size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//本段代码使用到的寄存器数目</span>    ushort                         ins_size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//method 传入参数的数目</span>    ushort                         outs_size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//本段代码调用其它 method 时需要的参数个数</span>    ushort                         tries_size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//try_item 结构的个数</span>    uint                         debug_info_off<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//偏移地址，指向本段代码的 debug 信息存放位置，是一个 debug_info_item 结构</span>    uint                         insns_size<span class="token punctuation">;</span>    ushort                         insns <span class="token punctuation">[</span>insns_size<span class="token punctuation">]</span><span class="token punctuation">;</span>     ushort                         paddding<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// optional</span>    try_item                     tries <span class="token punctuation">[</span>tyies_size<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// optional</span>    encoded_catch_handler_list  handlers<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// optional</span><span class="token punctuation">}</span><span class="token keyword">struct</span> debug_info_off<span class="token punctuation">{</span>    uleb128 line_start<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//状态机的 line 寄存器的初始值。不表示实际的位置条目</span>    uleb128 parameters_size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//已编码的参数名称的数量。每个方法参数都应该有一个名称，但不包括实例方法的 this（如果有）</span>    uleb128p1<span class="token punctuation">[</span>parameters_size<span class="token punctuation">]</span> paramer_names<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//方法参数名称的字符串索引。NO_INDEX 的编码值表示该关联参数没有可用的名称。该类型描述符和签名隐含在方法描述符和签名中</span><span class="token punctuation">}</span></code></pre><h6 id="class-def-item中的static-value-off"><a href="#class-def-item中的static-value-off" class="headerlink" title="class_def_item中的static_value_off"></a>class_def_item中的static_value_off</h6><pre class=" language-c"><code class="language-c">uleb128  <span class="token keyword">unsigned</span> LEB128<span class="token punctuation">,</span> valriable length<span class="token keyword">struct</span> encoded_array_item<span class="token punctuation">{</span>    encoded_array value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//表示encoded_value 个数</span><span class="token punctuation">}</span><span class="token keyword">struct</span> encoded_array<span class="token punctuation">{</span>        uleb128 size<span class="token punctuation">;</span>    encoded_value values<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="map-list"><a href="#map-list" class="headerlink" title="map_list"></a>map_list</h5><p>我们在前面已经提到过这个map_list,他里面的内容是保存header中对应的描述,里面描述的更加全面，具体的结构如下</p><p>map_list 里先用一个 uint 描述后面有 size 个 map_item，后续就是对应的 size 个 map_item 描述。 map_item 结构有 4 个元素: type 表示该 map_item 的类型，Dalvik Executable Format 里 Type Code 的定义; size 表示再细分此 item，该类型的个数;offset 是第一个元素的针对文件初始位置的偏移量; unuse 是用对齐字节的，无实际用处。</p><pre class=" language-c"><code class="language-c">ushort <span class="token number">16</span><span class="token operator">-</span>bit <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> little<span class="token operator">-</span>endianuint   <span class="token number">32</span><span class="token operator">-</span>bit <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> little<span class="token operator">-</span>endian<span class="token keyword">struct</span> map_list <span class="token punctuation">{</span>    uint     size<span class="token punctuation">;</span>    map_item list <span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">struct</span> map_item <span class="token punctuation">{</span>    ushort type<span class="token punctuation">;</span>     ushort unuse<span class="token punctuation">;</span>     uint   size<span class="token punctuation">;</span>     uint   offset<span class="token punctuation">;</span><span class="token punctuation">}</span> </code></pre><h5 id="leb128编码"><a href="#leb128编码" class="headerlink" title="leb128编码"></a>leb128编码</h5><p>Dalvik使用readUnsignedLeb128函数来尝试读取一个leb128编码的数值（代码位于dalvik\libdex\Leb128.h中）,那么什么是uleb128呢？</p><p>LEB128即”Little-Endian Base 128”，基于128的小端序编码格式，是对任意有符号或者无符号整型数的可变长度的编码。用LEB128编码的正数，会根据数字的大小改变所占字节数。在android的.dex文件中，他只用来编码32bits的整型数。</p><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/uleb128.png?raw=true" alt="img"></p><p>例子</p><pre><code>LEB128编码的0x02b0 ---&gt; 转换后的数字0x0130转换过程：0x02b0 ---&gt; 0000 0010 1011 0000 --&gt;去除最高位--&gt; 000 0010 011 0000 --&gt;按4bits重排 --&gt; 00 0001 0011 0000 --&gt; 0x130</code></pre><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* * Reads an unsigned LEB128 value, updating the given pointer to point * just past the end of the read value. This function tolerates * non-zero high-order bits in the fifth encoded byte. */</span>DEX_INLINE <span class="token keyword">int</span> <span class="token function">readSignedLeb128</span><span class="token punctuation">(</span><span class="token keyword">const</span> u1<span class="token operator">*</span><span class="token operator">*</span> pStream<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> u1<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token operator">*</span>pStream<span class="token punctuation">;</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>ptr<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;=</span> <span class="token number">0x7f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        result <span class="token operator">=</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;&lt;</span> <span class="token number">25</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">25</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>ptr<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        result <span class="token operator">=</span> <span class="token punctuation">(</span>result <span class="token operator">&amp;</span> <span class="token number">0x7f</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cur <span class="token operator">&amp;</span> <span class="token number">0x7f</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> <span class="token number">0x7f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">=</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;&lt;</span> <span class="token number">18</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">18</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            cur <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>ptr<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            result <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>cur <span class="token operator">&amp;</span> <span class="token number">0x7f</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">14</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> <span class="token number">0x7f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                result <span class="token operator">=</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;&lt;</span> <span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">11</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                cur <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>ptr<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                result <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>cur <span class="token operator">&amp;</span> <span class="token number">0x7f</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">21</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> <span class="token number">0x7f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    result <span class="token operator">=</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    cur <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>ptr<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    result <span class="token operator">|</span><span class="token operator">=</span> cur <span class="token operator">&lt;&lt;</span> <span class="token number">28</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token operator">*</span>pStream <span class="token operator">=</span> ptr<span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>对应的Kotlin代码，我自己写的功能，请大家参考</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">decodeUleb128</span><span class="token punctuation">(</span><span class="token keyword">data</span><span class="token operator">:</span> ByteArray<span class="token punctuation">)</span><span class="token operator">:</span> Long <span class="token punctuation">{</span>    <span class="token keyword">var</span> result<span class="token operator">:</span> Long <span class="token operator">=</span> <span class="token number">0L</span>    <span class="token label symbol">parserByte@</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>index <span class="token keyword">in</span> <span class="token keyword">data</span><span class="token punctuation">.</span>indices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">val</span> cur <span class="token operator">=</span> <span class="token keyword">data</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toUInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">when</span> <span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token number">0</span> <span class="token operator">-></span> <span class="token punctuation">{</span>                result <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token function">toLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> 127u<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//就一个byte，直接赋值，跳出循环</span>                    <span class="token keyword">break</span><span class="token label symbol">@parserByte</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//最高位为1,继续保存值到result里面，继续下一次循环</span>            <span class="token punctuation">}</span>            <span class="token number">1</span> <span class="token operator">-></span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//拼接数据,这里对result的值进行and操作，去掉高位数据</span>                <span class="token keyword">val</span> lowVal <span class="token operator">=</span> <span class="token punctuation">(</span>result <span class="token operator">and</span> <span class="token number">0x7f</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">val</span> hiVal <span class="token operator">=</span> <span class="token punctuation">(</span>cur <span class="token operator">and</span> 127u<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">shl</span> <span class="token number">7</span>                result <span class="token operator">=</span> <span class="token punctuation">(</span>lowVal <span class="token operator">or</span> hiVal<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> 127u<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//如果最高位不是0,没有数据了，直接返回</span>                    <span class="token keyword">break</span><span class="token label symbol">@parserByte</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//什么都不做，等着下一次循环，继续操作</span>            <span class="token punctuation">}</span>            <span class="token number">2</span> <span class="token operator">-></span> <span class="token punctuation">{</span>                <span class="token keyword">val</span> hiVal <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cur <span class="token operator">and</span> 127u<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">shl</span> <span class="token number">14</span><span class="token punctuation">)</span>                result <span class="token operator">=</span> result <span class="token operator">or</span> hiVal<span class="token punctuation">.</span><span class="token function">toLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> 127u<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token label symbol">@parserByte</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token number">3</span> <span class="token operator">-></span> <span class="token punctuation">{</span>                <span class="token keyword">val</span> hiVal <span class="token operator">=</span> <span class="token punctuation">(</span>cur <span class="token operator">and</span> 127u<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">shl</span> <span class="token number">21</span>                result <span class="token operator">=</span> result <span class="token operator">or</span> hiVal<span class="token punctuation">.</span><span class="token function">toLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> 127u<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token label symbol">@parserByte</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token number">4</span> <span class="token operator">-></span> <span class="token punctuation">{</span>                <span class="token keyword">val</span> hiVal <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">shl</span> <span class="token number">28</span>                result <span class="token operator">=</span> result <span class="token operator">or</span> hiVal<span class="token punctuation">.</span><span class="token function">toLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> 127u<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token label symbol">@parserByte</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Dex </tag>
            
            <tag> 文件结构 </tag>
            
            <tag> 二进制 </tag>
            
            <tag> 解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>X64汇编语言学习笔记</title>
      <link href="/2019/12/18/assembly-x64-01/"/>
      <url>/2019/12/18/assembly-x64-01/</url>
      
        <content type="html"><![CDATA[<h3 id="X64-汇编语言学习"><a href="#X64-汇编语言学习" class="headerlink" title="X64 汇编语言学习"></a>X64 汇编语言学习</h3><p>1.首先我们使用的开发环境为Ubuntu X64的系统,我默认使用的是kUbuntu,如果你是其的版本,也没有问题</p><pre class=" language-shell"><code class="language-shell">sudo apt-get install nasm</code></pre><p>安装以后就可以写测试程序了</p><pre class=" language-nasm"><code class="language-nasm"><span class="token keyword">section .data</span>    msg    db <span class="token string">"hello, world!"</span>,<span class="token string">`\n`</span><span class="token keyword">section .text</span>    <span class="token keyword">global    _start</span><span class="token label function">_start:</span>    <span class="token comment" spellcheck="true">;; write syscall</span>    mov    <span class="token register variable">rax</span>, <span class="token number">1</span>    <span class="token comment" spellcheck="true">;; file descriptor, standard output</span>    mov    <span class="token register variable">rdi</span>, <span class="token number">1</span>    <span class="token comment" spellcheck="true">;; message address</span>    mov    <span class="token register variable">rsi</span>, msg    <span class="token comment" spellcheck="true">;; length of message</span>    mov    <span class="token register variable">rdx</span>, <span class="token number">14</span>    <span class="token comment" spellcheck="true">;; call write syscall</span>    syscall    <span class="token comment" spellcheck="true">;; exit</span>    mov    <span class="token register variable">rax</span>, <span class="token number">60</span>    mov    <span class="token register variable">rdi</span>, <span class="token number">0</span>    syscall</code></pre><p>代码中使用了两个section,一个是data 一个是text</p><pre class=" language-nasm"><code class="language-nasm"><span class="token operator">/</span><span class="token operator">/</span>编译代码,生成hello.o文件<span class="token operator">$</span> nasm <span class="token operator">-</span>f elf64 <span class="token operator">-</span>o hello.o hello.asm<span class="token operator">/</span><span class="token operator">/</span>链接代码,把hello.o生成hello文件<span class="token operator">$</span> ld <span class="token operator">-</span>o hello hello.o</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Assembly </tag>
            
            <tag> X64 </tag>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 代码优化与混淆</title>
      <link href="/2019/12/14/android-dai-ma-you-hua-yu-hun-yao/"/>
      <url>/2019/12/14/android-dai-ma-you-hua-yu-hun-yao/</url>
      
        <content type="html"><![CDATA[<h4 id="Android-代码优化与混淆"><a href="#Android-代码优化与混淆" class="headerlink" title="Android 代码优化与混淆"></a>Android 代码优化与混淆</h4><h3 id="1-android代码优化"><a href="#1-android代码优化" class="headerlink" title="1.android代码优化"></a>1.android代码优化</h3><p>andriod gradle 插件3.4.0版本以上，不在使用ProGurad执行编译代码优化工作，转而使用R8编译器一起处理代码</p><pre class=" language-json"><code class="language-json"><span class="token number">1</span><span class="token punctuation">)</span> 压缩代码，检测依赖库，安全的移除未使用的类，字段，方法和属性，使用 minifyEnabled <span class="token boolean">true</span> 启用代码压缩android <span class="token punctuation">{</span>        ...        buildTypes <span class="token punctuation">{</span>            release <span class="token punctuation">{</span>                minifyEnabled <span class="token boolean">true</span>  //启用R8代码压缩                proguardFiles getDefaultProguardFile(                  'proguard-android-optimize.txt'<span class="token punctuation">)</span><span class="token punctuation">,</span>                  // List additional ProGuard rules for the given build type here. By default<span class="token punctuation">,</span>                  // Android Studio creates and includes an empty rules file for you (located                  // at the root directory of each module<span class="token punctuation">)</span>.                  'proguard-rules.pro'            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-json"><code class="language-json"><span class="token number">2</span><span class="token punctuation">)</span> 压缩资源，移除未使用的资源，包括应用的库依赖项中未使用的资源，要启用资源压缩，请在 build.gradle 文件中将 shrinkResources 属性设为 <span class="token boolean">true</span>（在用于代码压缩的 minifyEnabled 旁边）android <span class="token punctuation">{</span>        ...        buildTypes <span class="token punctuation">{</span>            release <span class="token punctuation">{</span>                shrinkResources <span class="token boolean">true</span>                minifyEnabled <span class="token boolean">true</span>                proguardFiles getDefaultProguardFile('proguard-android.txt'<span class="token punctuation">)</span><span class="token punctuation">,</span>                        'proguard-rules.pro'            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-json"><code class="language-json"><span class="token number">3</span><span class="token punctuation">)</span> 混淆，减少类，成员名称长度，从而减小dex文件体积R8 使用 ProGuard 规则文件来修改其默认行为并更好地了解应用的结构，如充当应用代码入口点的类。&lt;module-dir>/proguard-rules.pro默认情况下，此文件不应用任何规则，这里可以应用你自己的规则，progrard规则请看后面的proguard混淆规则Android Gradle 插件在编译时候会生成 proguard-android-optimize.txt（其中包含对大多数 Android 项目都有用的规则），并启用 @Keep* 注解AAR 库：&lt;library-dir>/proguard.txt如果某个 AAR 库是使用它自己的 ProGuard 规则文件发布的，并且您将该 AAR 库添加为编译时依赖项，则 R8 会在编译项目时自动应用其规则。JAR 库：&lt;library-dir>/META-INF/proguard/因为 ProGuard 规则是累加的，所以 AAR 库依赖项包含的某些规则无法移除，并且可能会影响应用其他部分的编译。例<span class="token punctuation">,</span>如果某个库包含停用代码优化的规则，该规则将针对整个项目停用优化。</code></pre><pre class=" language-json"><code class="language-json"><span class="token number">4</span><span class="token punctuation">)</span> 代码优化，检查并重写代码，以进一步减小应用 DEX 文件的大小。如果您的代码从不采用给定 if/else 语句的 else <span class="token punctuation">{</span><span class="token punctuation">}</span> 分支，R8 可能会移除 else <span class="token punctuation">{</span><span class="token punctuation">}</span> 分支的代码。如果您的代码只在一个位置调用某个方法，R8 可能会移除该方法而将其内嵌在这一个调用点。如果 R8 确定某个类只有一个唯一的子类且该类本身未实例化（例如，一个抽象基类仅由一个具体实现类使用），那么 R8 可以将这两个类组合在一起并从应用中移除一个类。R8代码优化举例，如下代码class MyActivity extends Activity <span class="token punctuation">{</span>  @Override void onCreate(Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    super.onCreate(savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>    String name = this.getClass(<span class="token punctuation">)</span>.getSimpleName(<span class="token punctuation">)</span><span class="token punctuation">;</span>//这是一个很普通的getClass方法调用，但是这个会产生反射调用    Log.e(name<span class="token punctuation">,</span> <span class="token string">"Hello!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>//-----------------------------------------ByteCode--------------------------------------------------<span class="token punctuation">[</span>0003d0<span class="token punctuation">]</span> MyActivity.onCreate<span class="token operator">:</span>(Landroid/os/Bundle<span class="token punctuation">;</span><span class="token punctuation">)</span>V<span class="token number">0000</span><span class="token operator">:</span> invoke-super <span class="token punctuation">{</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">}</span><span class="token punctuation">,</span> Landroid/app/Activity<span class="token punctuation">;</span>.onCreate<span class="token operator">:</span>(Landroid/os/Bundle<span class="token punctuation">;</span><span class="token punctuation">)</span>V<span class="token number">0003</span><span class="token operator">:</span> invoke-virtual <span class="token punctuation">{</span>v1<span class="token punctuation">}</span><span class="token punctuation">,</span> Ljava/lang/Object<span class="token punctuation">;</span>.getClass<span class="token operator">:</span>(<span class="token punctuation">)</span>Ljava/lang/Class<span class="token punctuation">;</span><span class="token number">0006</span><span class="token operator">:</span> move-result-object v2<span class="token number">0007</span><span class="token operator">:</span> invoke-virtual <span class="token punctuation">{</span>v2<span class="token punctuation">}</span><span class="token punctuation">,</span> Ljava/lang/Class<span class="token punctuation">;</span>.getSimpleName<span class="token operator">:</span>(<span class="token punctuation">)</span>Ljava/lang/String<span class="token punctuation">;</span>  //invoke-virtual调用000a<span class="token operator">:</span> move-result-object v2R8会扫描程序，并分析知道MyActivity根本没有被继承，即使你没有给它加final，这个时候R8会使用MyActivity.class来取代this.getClass(<span class="token punctuation">)</span>的调用，最终的代码可能如下所示//-----------------------------------------ByteCode--------------------------------------------------<span class="token number">0000</span><span class="token operator">:</span> invoke-super <span class="token punctuation">{</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">}</span><span class="token punctuation">,</span> Landroid/app/Activity<span class="token punctuation">;</span>.onCreate<span class="token operator">:</span>(Landroid/os/Bundle<span class="token punctuation">;</span><span class="token punctuation">)</span>V<span class="token number">0003</span><span class="token operator">:</span> const-string v2<span class="token punctuation">,</span> <span class="token string">"MyActivity"</span></code></pre><h5 id="开启更积极的R8优化"><a href="#开启更积极的R8优化" class="headerlink" title="开启更积极的R8优化"></a>开启更积极的R8优化</h5><p>R8 包含一组额外的优化功能，默认情况下未启用这些功能。您可以通过在项目的 gradle.properties 文件中添加以下代码来启用这些额外的优化功能：</p><pre class=" language-json"><code class="language-json">android.enableR8.fullMode=<span class="token boolean">true</span></code></pre><p>由于额外的优化功能使得 R8 的行为与 ProGuard 不同，因此它们可能要求您添加额外的 ProGuard 规则以避免运行时问题。例如，假设您的代码通过 Java Reflection API 引用一个类。默认情况下，R8 假设您打算在运行时检查和操纵该类的对象（即使您的代码实际上并不这样做），因此它会自动保留该类及其静态初始化程序。不过，在使用“完整模式”时，R8 不会做出这种假设，如果 R8 断言您的代码从不在运行时使用该类，它会从应用的最终 DEX 中移除该类。也就是说，如果要保留该类及其静态初始化程序，需要在规则文件中添加相应的保留规则。</p><h5 id="让R8生成移除代码报告"><a href="#让R8生成移除代码报告" class="headerlink" title="让R8生成移除代码报告"></a>让R8生成移除代码报告</h5><p>为了防止优化后出现问题，并帮助开发者发现优化后的问，我们可以查看R8的优化报告，找到具体优化了那些东西，对于要生成报告的模块，请将-printusage <output-dir>/usage.txt 添加到自定义规则文件内。</p><p>当启用R8并编译应用的时候，R8会输出指定路径的报告</p><p>#####　移除代码报告例子如下</p><pre class=" language-java"><code class="language-java">androidx<span class="token punctuation">.</span>drawerlayout<span class="token punctuation">.</span>R$attr    androidx<span class="token punctuation">.</span>vectordrawable<span class="token punctuation">.</span>R    androidx<span class="token punctuation">.</span>appcompat<span class="token punctuation">.</span>app<span class="token punctuation">.</span>AppCompatDelegateImpl        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSupportActionBar</span><span class="token punctuation">(</span>androidx<span class="token punctuation">.</span>appcompat<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>Toolbar<span class="token punctuation">)</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasWindowFeature</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setHandleNativeActionModesEnabled</span><span class="token punctuation">(</span><span class="token keyword">boolean</span><span class="token punctuation">)</span>        android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>ViewGroup <span class="token function">getSubDecor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLocalNightMode</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>        <span class="token keyword">final</span> androidx<span class="token punctuation">.</span>appcompat<span class="token punctuation">.</span>app<span class="token punctuation">.</span>AppCompatDelegateImpl$AutoNightModeManager <span class="token function">getAutoNightModeManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> androidx<span class="token punctuation">.</span>appcompat<span class="token punctuation">.</span>app<span class="token punctuation">.</span>ActionBarDrawerToggle$Delegate <span class="token function">getDrawerToggleDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> DEBUG        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String KEY_LOCAL_NIGHT_MODE        <span class="token keyword">static</span> <span class="token keyword">final</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String EXCEPTION_HANDLER_MESSAGE_SUFFIX    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><h5 id="生成保留规则确定的入口点报告"><a href="#生成保留规则确定的入口点报告" class="headerlink" title="生成保留规则确定的入口点报告"></a>生成保留规则确定的入口点报告</h5><p>如果要查看 R8 根据项目的保留规则确定的入口点的报告，请在自定义规则文件中添加 -printseeds <output-dir>/seeds.txt。当启用 R8 并编译应用时，R8 会输出一个包含您指定的路径和文件名的报告。保留的入口点的报告与以下输出类似：</p><pre class=" language-java"><code class="language-java">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>myapplication<span class="token punctuation">.</span>MainActivity    androidx<span class="token punctuation">.</span>appcompat<span class="token punctuation">.</span>R$layout<span class="token operator">:</span> <span class="token keyword">int</span> abc_action_menu_item_layout    androidx<span class="token punctuation">.</span>appcompat<span class="token punctuation">.</span>R$attr<span class="token operator">:</span> <span class="token keyword">int</span> activityChooserViewStyle    androidx<span class="token punctuation">.</span>appcompat<span class="token punctuation">.</span>R$styleable<span class="token operator">:</span> <span class="token keyword">int</span> MenuItem_android_id    androidx<span class="token punctuation">.</span>appcompat<span class="token punctuation">.</span>R$styleable<span class="token operator">:</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> CoordinatorLayout_Layout    androidx<span class="token punctuation">.</span>lifecycle<span class="token punctuation">.</span>FullLifecycleObserverAdapter    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><h3 id="2-proguard-混淆原理"><a href="#2-proguard-混淆原理" class="headerlink" title="2.proguard 混淆原理"></a>2.proguard 混淆原理</h3><p>ProGuard能够对Java类中的代码进行压缩（Shrink）,优化（Optimize）,混淆（Obfuscate）,预检（Preveirfy）。 </p><p>压缩（Shrink）:在压缩处理这一步中，用于检测和删除没有使用的类，字段，方法和属性。 </p><p>优化（Optimize）:在优化处理这一步中，对字节码进行优化，并且移除无用指令。 </p><p>混淆（Obfuscate）:在混淆处理这一步中，使用a,b,c等无意义的名称，对类，字段和方法进行重命名。 </p><p>预检（Preveirfy）:在预检这一步中，主要是在Java平台上对处理后的代码进行预检。</p><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/proguard.jpg?raw=true" alt=""></p><h3 id="2-proguard-rules-pro-混淆配置"><a href="#2-proguard-rules-pro-混淆配置" class="headerlink" title="2.proguard-rules.pro 混淆配置"></a>2.proguard-rules.pro 混淆配置</h3><h5 id="keep-选项"><a href="#keep-选项" class="headerlink" title="keep 选项"></a>keep 选项</h5><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">-keep</span> <span class="token attr-value">[,modifier，...] class_specification</span>指定需要保留的类和类成员（作为公共类库，应该保留所有可公开访问的public方法）<span class="token attr-name">-keepclassmembers</span> <span class="token attr-value">[,modifier，...] class_specification</span><span class="token attr-name">指定需要保留的类成员</span><span class="token punctuation">:</span><span class="token attr-value">变量或者方法</span><span class="token attr-name">-keepclasseswithmembers</span> <span class="token attr-value">[,modifier，...] class_specification</span>指定保留的类和类成员，条件是所指定的类成员都存在（既在压缩阶段没有被删除的成员，效果和keep差不多）<span class="token attr-name">-keepnames</span> <span class="token attr-value">class_specification</span><span class="token attr-name">[-keep</span> <span class="token attr-value">allowshrinking class_specification 的简写]</span>指定要保留名称的类和类成员，前提是在压缩阶段未被删除。仅用于模糊处理<span class="token attr-name">-keepclassmembernames</span> <span class="token attr-value">class_specification</span><span class="token attr-name">[-keepclassmembers</span> <span class="token attr-value">allowshrinking class_specification 的简写]</span>指定要保留名称的类成员，前提是在压缩阶段未被删除。仅用于模糊处理<span class="token attr-name">-keepclasseswithmembernames</span> <span class="token attr-value">class_specification</span><span class="token attr-name">[-keepclasseswithmembers</span> <span class="token attr-value">allowshrinking class_specification 的简写]</span>指定要保留名称的类成员，前提是在压缩阶段后所指定的类成员都存在。仅用于模糊处理</code></pre><h5 id="Keep选项概述对比"><a href="#Keep选项概述对比" class="headerlink" title="Keep选项概述对比"></a>Keep选项概述对比</h5><table><thead><tr><th>作用范围</th><th>保持所指定类、成员</th><th>所指定类、成员在压缩阶段没有被删除，才能被保持</th></tr></thead><tbody><tr><td>类和类成员</td><td>-keep</td><td>-keepnames</td></tr><tr><td>仅类成员</td><td>-keepclassmembers</td><td>-keepclassmembernames</td></tr><tr><td>类和类成员(前提是成员都存在)</td><td>-keepclasseswithmembers</td><td>-keepclasseswithmembernames</td></tr></tbody></table><h3 id="Proguard通配符"><a href="#Proguard通配符" class="headerlink" title="Proguard通配符"></a>Proguard通配符</h3><table><thead><tr><th>通配符</th><th>描述</th></tr></thead><tbody><tr><td><field></td><td>匹配类中的所有字段</td></tr><tr><td><method></td><td>匹配类中所有的方法</td></tr><tr><td><init></td><td>匹配类中所有的构造函数</td></tr><tr><td>*</td><td>匹配任意长度字符，不包含包名分隔符(.)</td></tr><tr><td>**</td><td>匹配任意长度字符，包含包名分隔符(.)</td></tr><tr><td>***</td><td>匹配任意参数类型</td></tr></tbody></table><h5 id="keep使用例子"><a href="#keep使用例子" class="headerlink" title="keep使用例子"></a>keep使用例子</h5><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 保留所有的本地native方法不被混淆</span><span class="token attr-name">-keepclasseswithmembernames</span> <span class="token attr-value">class * {</span><span class="token attr-name">    native</span> <span class="token attr-value">&lt;methods>;</span>}<span class="token comment" spellcheck="true"># 保留了继承自Activity、Application这些类的子类</span><span class="token comment" spellcheck="true"># 因为这些子类，都有可能被外部调用</span><span class="token comment" spellcheck="true"># 比如说，第一行就保证了所有Activity的子类不要被混淆</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class * extends android.app.Activity</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class * extends android.app.Application</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class * extends android.app.Service</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class * extends android.content.BroadcastReceiver</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class * extends android.content.ContentProvider</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class * extends android.app.backup.BackupAgentHelper</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class * extends android.preference.Preference</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class * extends android.view.View</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class com.android.vending.licensing.ILicensingService</span><span class="token comment" spellcheck="true"># 保留在Activity中的方法参数是view的方法，</span><span class="token comment" spellcheck="true"># 从而我们在layout里面编写onClick就不会被影响</span><span class="token attr-name">-keepclassmembers</span> <span class="token attr-value">class * extends android.app.Activity {</span><span class="token attr-name">    public</span> <span class="token attr-value">void *(android.view.View);</span>}<span class="token comment" spellcheck="true"># 枚举类不能被混淆</span><span class="token attr-name">-keepclassmembers</span> <span class="token attr-value">enum * {</span><span class="token attr-name">    public</span> <span class="token attr-value">static **[] values();</span><span class="token attr-name">    public</span> <span class="token attr-value">static ** valueOf(java.lang.String);</span>}<span class="token comment" spellcheck="true"># 保留自定义控件（继承自View）不被混淆</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class * extends android.view.View {</span><span class="token attr-name">    ***</span> <span class="token attr-value">get*();</span><span class="token attr-name">    void</span> <span class="token attr-value">set*(***);</span><span class="token attr-name">    public</span> <span class="token attr-value">&lt;init>(android.content.Context);</span><span class="token attr-name">    public</span> <span class="token attr-value">&lt;init>(android.content.Context, android.util.AttributeSet);</span><span class="token attr-name">    public</span> <span class="token attr-value">&lt;init>(android.content.Context, android.util.AttributeSet, int);</span><span class="token comment" spellcheck="true">    #这里需要注意,其实目前最新的View有第四个构造参数,所以混淆的时候一定记得加上,这样防止出现崩溃</span>}<span class="token comment" spellcheck="true"># 保留Parcelable序列化的类不被混淆</span><span class="token attr-name">-keep</span> <span class="token attr-value">class * implements android.os.Parcelable {</span><span class="token attr-name">    public</span> <span class="token attr-value">static final android.os.Parcelable$Creator *;</span>}<span class="token comment" spellcheck="true"># 保留Serializable序列化的类不被混淆</span><span class="token attr-name">-keepclassmembers</span> <span class="token attr-value">class * implements java.io.Serializable {</span><span class="token attr-name">    static</span> <span class="token attr-value">final long serialVersionUID;</span><span class="token attr-name">    private</span> <span class="token attr-value">static final java.io.ObjectStreamField[] serialPersistentFields;</span><span class="token attr-name">    private</span> <span class="token attr-value">void writeObject(java.io.ObjectOutputStream);</span><span class="token attr-name">    private</span> <span class="token attr-value">void readObject(java.io.ObjectInputStream);</span><span class="token attr-name">    java.lang.Object</span> <span class="token attr-value">writeReplace();</span><span class="token attr-name">    java.lang.Object</span> <span class="token attr-value">readResolve();</span>}<span class="token comment" spellcheck="true"># 对于R（资源）下的所有类及其方法，都不能被混淆</span><span class="token attr-name">-keep</span> <span class="token attr-value">class **.R$* {</span>    *;}<span class="token comment" spellcheck="true"># 对于带有回调函数onXXEvent的，不能被混淆</span><span class="token attr-name">-keepclassmembers</span> <span class="token attr-value">class * {</span><span class="token attr-name">    void</span> <span class="token attr-value">*(**On*Event);</span>}<span class="token comment" spellcheck="true"># 保留实体类和成员不被混淆</span><span class="token comment" spellcheck="true"># 对于实体，保留它们的set和get方法，对于boolean型get方法，有人喜欢命名isXXX的方式，所以不要遗漏。</span><span class="token comment" spellcheck="true">#一种好的做法是把所有实体都放在一个包下进行管理，这样只写一次混淆就够了，避免以后在别的包中新增的实体而忘记保留，代码在混淆后因为找不到相应的实体类而崩溃。</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class com.xxxx.entity.** {</span><span class="token attr-name">    public</span> <span class="token attr-value">void set*(***);</span><span class="token attr-name">    public</span> <span class="token attr-value">*** get*();</span><span class="token attr-name">    public</span> <span class="token attr-value">*** is*();</span>}<span class="token comment" spellcheck="true"># 保留内嵌类不被混淆</span><span class="token comment" spellcheck="true"># 内部类经常会被混淆，结果在调用的时候为空就崩溃了，最好的解决方法就是把这个内部类拿出来，单独成为一个类。如果一定要内置，那么这个类就必须在混淆的时候保留，建议少用内部类</span><span class="token attr-name">-keep</span> <span class="token attr-value">class com.example.xxx.MainActivity$* { *; }</span><span class="token comment" spellcheck="true">#针对WebView的处理</span><span class="token comment" spellcheck="true">#如果使用的是腾讯的x5浏览器，请到腾讯x5浏览器官网获得keep的具体内容</span><span class="token attr-name">-keepclassmembers</span> <span class="token attr-value">class * extends android.webkit.webViewClient {</span><span class="token attr-name">    public</span> <span class="token attr-value">void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap);</span><span class="token attr-name">    public</span> <span class="token attr-value">boolean *(android.webkit.WebView, java.lang.String)</span>}<span class="token attr-name">-keepclassmembers</span> <span class="token attr-value">class * extends android.webkit.we使用annotationbViewClient {</span><span class="token attr-name">    public</span> <span class="token attr-value">void *(android.webkit.webView, java.lang.String)</span>}<span class="token comment" spellcheck="true">#对应的Java层的js方法也要进行keep</span><span class="token attr-name">-keepclassmembers</span> <span class="token attr-value">class com.example.xxx.JSInterface{</span>    &lt;methods>;}</code></pre><h5 id="针对反射的处理"><a href="#针对反射的处理" class="headerlink" title="针对反射的处理"></a>针对反射的处理</h5><p>在程序中使用SomeClass.class.method这样的静态方法，在ProGuard中是在压缩过程中被保留的，那么对于Class.forName(“SomeClass”)呢，SomeClass不会被压缩过程中移除，它会检查程序中使用的Class.forName方法，对参数SomeClass法外开恩，不会被移除。但是在混淆过程中，无论是Class.forName(“SomeClass”)，还是SomeClass.class，都不能蒙混过关，SomeClass这个类名称会被混淆，因此，我们要在ProGuard.cfg文件中保留这个类名称。<br>Class.forName(“SomeClass”)<br>SomeClass.class<br>SomeClass.class.getField(“someField”)<br>SomeClass.class.getDeclaredField(“someField”)<br>SomeClass.class.getMethod(“someMethod”, new Class[] {})<br>SomeClass.class.getMethod(“someMethod”, new Class[] { A.class })<br>SomeClass.class.getMethod(“someMethod”, new Class[] { A.class, B.class })<br>SomeClass.class.getDeclaredMethod(“someMethod”, new Class[] {})<br>SomeClass.class.getDeclaredMethod(“someMethod”, new Class[] { A.class })<br>SomeClass.class.getDeclaredMethod(“someMethod”, new Class[] { A.class, B.class })<br>AtomicIntegerFieldUpdater.newUpdater(SomeClass.class, “someField”)<br>AtomicLongFieldUpdater.newUpdater(SomeClass.class, “someField”)<br>AtomicReferenceFieldUpdater.newUpdater(SomeClass.class, SomeType.class, “someField”)<br>在混淆的时候，要在项目中搜索一下上述方法，将相应的类或者方法的名称进行保留而不被混淆。</p><h5 id="第三方开发库的混淆"><a href="#第三方开发库的混淆" class="headerlink" title="第三方开发库的混淆"></a>第三方开发库的混淆</h5><p>一般情况第三方的开发库都会提供混淆的配置，如果没有，可以使用下面类似的模板</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 针对android-support-v4.jar的解决方案,可以按照此模板进行修改</span><span class="token comment" spellcheck="true">#不是每个第三方SDK都需要-dontwarn 指令，这取决于混淆时第三方SDK是否出现警告，需要的时候再加上。</span><span class="token attr-name">-libraryjars</span> <span class="token attr-value">libs/android-support-v4.jar</span><span class="token attr-name">-dontwarn</span> <span class="token attr-value">android.support.v4.**</span><span class="token attr-name">-keep</span> <span class="token attr-value">class android.support.v4.**  { *; }</span><span class="token attr-name">-keep</span> <span class="token attr-value">interface android.support.v4.app.** { *; }</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class * extends android.support.v4.**</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class * extends android.app.Fragment</span></code></pre><p>对于自定义类库的混淆处理,比如我们引用了一个叫做AndroidLib的类库，我们需要对Lib也进行混淆，然后在主项目的混淆文件中保留AndroidLib中的类和类的成员。</p><h5 id="Anroid-官方建议-不混淆的，如"><a href="#Anroid-官方建议-不混淆的，如" class="headerlink" title="Anroid 官方建议 不混淆的，如"></a>Anroid 官方建议 不混淆的，如</h5><pre class=" language-properties"><code class="language-properties">android.app.backup.BackupAgentHelperandroid.preference.Preferencecom.android.vending.licensing.ILicensingService</code></pre><h5 id="使用annotation避免混淆"><a href="#使用annotation避免混淆" class="headerlink" title="使用annotation避免混淆"></a>使用annotation避免混淆</h5><p>@keep<br>@keepPublicGetterSetters<br>public class DemoBean{<br>    public  boolean booleanProperty;<br>    public  int intProperty;<br>    public  String stringProperty;<br>}</p><h5 id="对于Kotlin的支持"><a href="#对于Kotlin的支持" class="headerlink" title="对于Kotlin的支持"></a>对于Kotlin的支持</h5><p>目前Progurad对kotlin的支持版本还是beta版本</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#针对kotlin代码混淆的keep内容</span><span class="token attr-name">-keep</span> <span class="token attr-value">class kotlin.** { *; }</span><span class="token attr-name">-keep</span> <span class="token attr-value">class kotlin.Metadata { *; }</span><span class="token attr-name">-dontwarn</span> <span class="token attr-value">kotlin.**</span><span class="token comment" spellcheck="true">#maping 枚举方法需要keep</span><span class="token attr-name">-keepclassmembers</span> <span class="token attr-value">class **$WhenMappings {</span>    &lt;fields>;}<span class="token comment" spellcheck="true">#针对metadata元数据的public方法</span><span class="token attr-name">-keepclassmembers</span> <span class="token attr-value">class kotlin.Metadata {</span><span class="token attr-name">    public</span> <span class="token attr-value">&lt;methods>;</span>}<span class="token comment" spellcheck="true">#针对checkParameterIsNotNull这个方法</span><span class="token attr-name">-assumenosideeffects</span> <span class="token attr-value">class kotlin.jvm.internal.Intrinsics {</span><span class="token attr-name">    static</span> <span class="token attr-value">void checkParameterIsNotNull(java.lang.Object, java.lang.String);</span>}</code></pre><h5 id="最后要说的一点"><a href="#最后要说的一点" class="headerlink" title="最后要说的一点"></a>最后要说的一点</h5><p>因为现在的R8,我找到了一些新功能,比如支持java内联替换功能,但是我测试没有成功,如果哪位有测试成功了,请与我分享一下.非常感谢.个人认为R8的内联功能还是非常实用的,能够实现很多有趣的玩法.最后感谢大家.</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 混淆 </tag>
            
            <tag> R8 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何调试已经加壳的APK文件</title>
      <link href="/2019/12/11/debug-apk/"/>
      <url>/2019/12/11/debug-apk/</url>
      
        <content type="html"><![CDATA[<p>今天有个任务,让我去调试一个APK,需要查看它的性能参数,内存/CPU等的占用,第一时间拿出工具准备反编译,但是发现此包使用了360加固,不确定是否有签名校验,如果有,我就没办法修改AndroidManifest.xml文件来打开调试了.</p><p>既然改包的方法不行,那就只能在系统层面想办法了,谁让我有root的手机呢.</p><p>一下操作需要root权限,如果没有的,请先root手机获取权限</p><p>打开手机的Re文件管理器,找到系统的/目录</p><p>如图,RE文件管理器</p><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/launchicon.png?raw=true" alt=""></p><p>打开系统的根目录 / ,选择default.prop文件</p><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/file.png?raw=true" alt=""></p><p>选择右上角的菜单,找到打开方式</p><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/openmenu.png?raw=true" alt=""></p><p>使用”以文本方式编辑”打开</p><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/opentype.jpg?raw=true" alt=""></p><p>把ro.secure 和ro.debuggable 字段都改成1,然后重启你的手机</p><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/edit.png?raw=true" alt=""></p><p>完毕以后就可以用数据线链接手机,进行性能测试了</p><p>如下图</p><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/run.jpg?raw=true" alt=""></p><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/cpu&mem.jpg?raw=true" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> apk </tag>
            
            <tag> 调试 </tag>
            
            <tag> root </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一些开发中的琐碎</title>
      <link href="/2019/12/09/tips/"/>
      <url>/2019/12/09/tips/</url>
      
        <content type="html"><![CDATA[<h5 id="1-ubuntu-安装gimp之后没有中文"><a href="#1-ubuntu-安装gimp之后没有中文" class="headerlink" title="1.ubuntu 安装gimp之后没有中文"></a>1.ubuntu 安装gimp之后没有中文</h5><p>一般出现在kubuntu上面,只要安装一下language-pack-gnome-zh-hant就可以了</p><pre><code>sudo apt-get install language-pack-gnome-zh-hant</code></pre><h5 id="2-IDA在64位ubuntu上面提示error-while-loading-shared-libraries-libgtk-x11-2-0-so-0-cannot-open-shared-object-file"><a href="#2-IDA在64位ubuntu上面提示error-while-loading-shared-libraries-libgtk-x11-2-0-so-0-cannot-open-shared-object-file" class="headerlink" title="2.IDA在64位ubuntu上面提示error while loading shared libraries: libgtk-x11-2.0.so.0: cannot open shared object file"></a>2.IDA在64位ubuntu上面提示error while loading shared libraries: libgtk-x11-2.0.so.0: cannot open shared object file</h5><p>这个问题主要是因为缺少开发库,虽然ida是64位的,但是还是有32位依赖库的东西,所以我们要安装一下32位的东西你,命令如下</p><pre class=" language-shell"><code class="language-shell">sudo apt-get install libgtk2.0-0:i386 libxxf86vm1:i386 libsm6:i386 lib32stdc++6</code></pre><h5 id="3-mac-系统中很多软件是32位的-但是10-15以后系统不允许运行了"><a href="#3-mac-系统中很多软件是32位的-但是10-15以后系统不允许运行了" class="headerlink" title="3.mac 系统中很多软件是32位的,但是10.15以后系统不允许运行了"></a>3.mac 系统中很多软件是32位的,但是10.15以后系统不允许运行了</h5><p>解决办法如下</p><pre class=" language-shell"><code class="language-shell">sudo spctl --master-disable</code></pre><h5 id="4-编译elfutils"><a href="#4-编译elfutils" class="headerlink" title="4.编译elfutils"></a>4.编译elfutils</h5><pre class=" language-shell"><code class="language-shell">autoheaderaclocal -I m4autoconfautomake -a -c./configuremake</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 小技巧 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 编译edb debugger</title>
      <link href="/2019/12/06/edb-debugger/"/>
      <url>/2019/12/06/edb-debugger/</url>
      
        <content type="html"><![CDATA[<h3 id="Ubuntu-编译edb-debugger"><a href="#Ubuntu-编译edb-debugger" class="headerlink" title="Ubuntu 编译edb debugger"></a>Ubuntu 编译edb debugger</h3><h4 id="1-首先安装第三方库"><a href="#1-首先安装第三方库" class="headerlink" title="1.首先安装第三方库"></a>1.首先安装第三方库</h4><pre class=" language-shell"><code class="language-shell">sudo apt-get install         cmake                                  \    build-essential        \    libboost-dev           \    libqt5xmlpatterns5-dev \    qtbase5-dev            \    qt5-default            \    libqt5svg5-dev         \    libgraphviz-dev        \    libcapstone-dev        \    pkg-config</code></pre><h4 id="2-获取edb-debugger源代码"><a href="#2-获取edb-debugger源代码" class="headerlink" title="2.获取edb-debugger源代码"></a>2.获取edb-debugger源代码</h4><pre class=" language-shell"><code class="language-shell">git clone --recursive https://github.com/eteran/edb-debugger.git</code></pre><h4 id="3-编译源代码"><a href="#3-编译源代码" class="headerlink" title="3.编译源代码"></a>3.编译源代码</h4><pre class=" language-shell"><code class="language-shell">cd edb-debuggermkdir buildcd buildcmake ..make -j8  //-j可以根据自己cpu的数量修改//最后需要安装到系统,可以执行,默认安装位置/usr/local/lib/edb/sudo make install</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 调试器 </tag>
            
            <tag> edb </tag>
            
            <tag> debugger </tag>
            
            <tag> debug </tag>
            
            <tag> OllyDbg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言学习之文件操作</title>
      <link href="/2017/04/11/go-file-op/"/>
      <url>/2017/04/11/go-file-op/</url>
      
        <content type="html"><![CDATA[<h3 id="2017年2月27日"><a href="#2017年2月27日" class="headerlink" title="2017年2月27日"></a>2017年2月27日</h3><blockquote><p>文件操作在编程中是非常重要的,我们经常操作的文件类型一般分为二进制文件和普通文本文件,因为文本文件与二进制文件的区别仅仅是编码上不同，所以他们的优缺点就是编码的优缺点.今天我们来学习一下如何用Go语言来建立和操作文件.</p></blockquote><ul><li>1.建立文件</li></ul><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"os"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    customFile<span class="token operator">:=</span><span class="token string">"customFile.dat"</span>    file<span class="token punctuation">,</span>err<span class="token operator">:=</span>os<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span>customFile<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//创建文件</span>    <span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">checkErr</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    file<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"Hello world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//使用Write写入数据.这里接受的是byte数组</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">checkErr</span><span class="token punctuation">(</span>err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>2.打开文件</li></ul><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"os"</span>    <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    customFile<span class="token operator">:=</span><span class="token string">"customFile.dat"</span>    file<span class="token punctuation">,</span>err<span class="token operator">:=</span>os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>customFile<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//打开文件</span>    <span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">checkErr</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    fileSize<span class="token punctuation">,</span>err<span class="token operator">:=</span>os<span class="token punctuation">.</span><span class="token function">Stat</span><span class="token punctuation">(</span>customFile<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//获取文件大小,用来开辟读取的空间</span>    <span class="token function">checkErr</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    data<span class="token operator">:=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span><span class="token function">int</span><span class="token punctuation">(</span>fileSize<span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//申请用来保存数据的空间</span>    file<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//读取数据</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//打印数组数据</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//打印字符串数据</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">checkErr</span><span class="token punctuation">(</span>err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 文件操作s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>教你如何将公交卡和手机合二为一</title>
      <link href="/2017/02/27/phone-card/"/>
      <url>/2017/02/27/phone-card/</url>
      
        <content type="html"><![CDATA[<h3 id="2017年2月23日"><a href="#2017年2月23日" class="headerlink" title="2017年2月23日"></a>2017年2月23日</h3><blockquote><p>平时我们经常会做公交或者地铁,刷卡是不可避免的,但是人多的时候,拿卡不方便,又是手机,又是包包,一堆东西很容易弄丢.为了方便,我今天教大家改造自己的手机,把公交卡装进手机.</p></blockquote><p>今天的方法有两种,一种推荐给动手能力强的同学,一种推荐给觉得麻烦的同学.</p><ul><li>1.第一种方法,操作比较复杂,需要我们有工具,并且有一定的动手能力,推荐喜欢折腾的同学.孙老师我就为了折腾这个,损坏了两张公交卡呢.不过没事,我是土豪,哈哈哈</li></ul><p>首先,我们平时用的公交卡,如下图<br><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/card.png?raw=true" alt=""></p><p>黑色记号笔所标记的地方是我们的公交卡芯片所在的位置,我们需要使用手电筒,照在卡的背面,沿着边缘里面一点一点的找,很快就能找到芯片所在的位置.</p><p>找到芯片的位置以后,我们需要的就是使用剪刀一类的工具,把芯片剪下来,记得多剪一些,防止损坏芯片.<br><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/card2.png?raw=true" alt=""></p><p>剪下来的芯片因为还是被塑料包裹着,依然不方便取出,这个时候,我们可以从万能的X宝买一些溶解塑料的溶解液,把芯片放进去,过几个小时就能溶解塑料,轻松获取芯片了.如果觉得动手能力很强,可以完整的用刀片取出,那也可以.不过祝你成功,骚年.<br><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/card3.png?raw=true" alt=""></p><p>拿到了芯片,接下来,我们要给芯片安装线圈了.首先还是要万能的X宝,有现成的可以买,当然你要是自己做,我也不拦着,主要是要各种试验,比较麻烦,而且容易损坏芯片.</p><p>有了线圈,就可以将芯片两端的金属和芯片进行焊接操作,不过千万要小心,芯片不耐热,烙铁要是在芯片上太久了,会损坏芯片的.</p><p>焊完的样子大概是这个样子的<br><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/card4.png?raw=true" alt=""></p><p>最后,还是X宝,买一个抗干扰防磁贴,贴在手机的背面,然后在把我们刚才焊接的芯片贴在磁贴的前面,外面再套上手机套,就可以完成了.</p><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/card5.png?raw=true" alt=""></p><p>这样做的好处就是手机和公交卡直接放在一起,坐车的时候直接刷一下手机就行了,虽然我的红米没有nfc,但是这样之后,我仍然可以冒充我有nfc,嘿嘿.</p><p>第一种方法的好处是整个手机的厚度基本不会增加,而且刷卡灵敏度也很好,但是动手操作的地方比较多,而且要小心,否则很容易损坏芯片,别问我怎么知道的(我已经损坏了两张卡了).</p><ul><li>2.第二种方法比较简单但是对手机的大小有要求,你的手机必须要大一些,这样能在手机壳下面装的下你的卡.推荐大家使用硅胶手机套,因为这个套套有弹性,手感好,还耐磨,耐磨,耐磨……嘿嘿嘿嘿</li></ul><p>首先拿出我们的卡,比较一下跟手机的大小,最好手机比我们的卡大上两圈.这样放进去更容易</p><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/phone001.jpg?raw=true" alt=""></p><p>下面是我们的卡和手机套对比.看看我们的卡是否能安装在手机和手机套之间.推荐最好选择硅胶套,有弹性,方便安装,而且外表不变形.</p><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/phone002.jpg?raw=true" alt=""></p><p>放入手机壳内,看看是否合适.</p><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/phone003.jpg?raw=true" alt=""></p><p>接下来,把我们从淘宝买的磁贴贴在我们的卡背面,然后磁贴这边贴着手机这面,我们的卡贴着硅胶套这面,然后放入我们的手机.</p><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/phone004.jpg?raw=true" alt=""></p><p>最后成功的样子!</p><p><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/phone005.jpg?raw=true" alt=""></p><p>总结:</p><p>两种方法都是可行的,我已经试过了.</p><p>那么第一种好出就是如果你的手机支持背壳可拆卸,你甚至可以把这个放在手机内部,但是操作麻烦,各种拆拆拆.动手能力差的同学不推荐.</p><p>第二个种的好出就是非常简单,适合动手能力弱的同学,但是第二种一般不适合喜欢裸奔的同学,需要手机套配合使用.</p><p>以上两种方法都可以让你实现公交卡和手机结合,让你的手机没有全NFC功能也一样可以刷公交卡,里面提到的一些东西,X宝都可以买到,价格便宜,动手改造一下自己的手机,方便生活.<br>谢谢大家,我是孙老师.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 手机 </tag>
            
            <tag> 公交卡 </tag>
            
            <tag> nfc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开博</title>
      <link href="/2017/02/22/hello-world/"/>
      <url>/2017/02/22/hello-world/</url>
      
        <content type="html"><![CDATA[<h3 id="2017年2月22日"><a href="#2017年2月22日" class="headerlink" title="2017年2月22日"></a>2017年2月22日</h3><p>博客开始创立<br>欢迎大家访问</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
